( nsmetrics-server.api.hardware
(:require [metrics-server.core :refer [call-api check-required-params with-collection-format]])
(:import( java.io File)))

(defn get-metrics-with-http-info
"Get hardware metrics"
[]
( call-api "/hardware" :get
{:path-params {}
:header-params {}
:query-params {}
:form-params {}
:content-types []
:accepts []
:auth-names []}))

(defn get-metrics
"Get hardware metrics"
[]
(:data (get-metrics-with-http-info)))

;; Список, укоторыхcpuTemp< 2
(defn task1 [get-metrics]
(filter (fn [x] (> (get x :cpuTemp) 2 ))get-metrics)
)

;; СредняяcpuTemp
(defn task2 [get-metrics]
(/ (reduce + (map (fn [x] (get x :cpuTemp)) get-metrics))
(count (filter (fn [x] (get x :cpuTemp))get-metrics)))
)

;; СредняяcpuLoad
(defn task3 [get-metrics]
(/ (reduce + (map (fn [x] (get x :cpuLoad)) get-metrics))
(count (filter (fn [x] (get x :cpuLoad))get-metrics)))
)

(defn -main [&args]
(println (task1(get-metrics)))
(println (task2(get-metrics)))
(println (task3(get-metrics)))
)
( nsmetrics-server.core
(:require [cheshire.core :refer [generate-string parse-string]]
[clojure.string :as str]
[clj-http.client :as client])
(:import (com.fasterxml.jackson.coreJsonParseException)
(java.io File)
(java.util Date TimeZone)
(java.textSimpleDateFormat)))

(def auth-definitions
{})

(def default-api-context
"Default API context."
{:base-url "http://madskills.ch:6874/metrics"
:date-format "yyyy-MM-dd"
:datetime-format "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
:debug false
:auths {}})

(def ^:dynamic *api-context*
"Dynamic API context to be applied in API calls."
default-api-context)

(defmacro with-api-context
"A helper macro to wrap *api-context* with default values."
[api-context & body]
`(let [api-context# ~api-context
api-context# (-> *api-context*
(merge api-context#)
(assoc :auths (merge (:auths *api-context*) (:authsapi-context#))))]
(binding [*api-context* api-context#]
~@body)))

(defmacro check-required-params
"Throw exception if any of the given parameters is nil."
[& params]
(-» params
(map (fn [p]
`(if (nil? ~p)
(throw (IllegalArgumentException. ~(str "The parameter \"" p "\" is required"))))))
(list* 'do)))

(defn with-collection-format
"Attach collection-format to meta data of the given parameter."
[param collection-format]
(and param (with-meta param {:collection-format collection-format})))

(defn- ^SimpleDateFormat make-date-format
([^String format-str] (make-date-format format-str nil))
([^String format-str ^String time-zone]
(let [date-format (SimpleDateFormat. format-str)]
(when time-zone
(.setTimeZone date-format (TimeZone/getTimeZone time-zone)))
date-format)))

(defn format-date
"Format the given Date object with the :date-format defined in *api-options*.
NOTE: The UTC time zone is used."
[^Date date]
(let [{:keys [date-format]} *api-context*]
(-> (make-date-format date-format "UTC")
(.format date))))

(defn parse-date
"Parse the given string to a Date object with the :date-format defined in *api-options*.
NOTE: The UTC time zone is used."
[^String s]
(let [{:keys [date-format]} *api-context*]
(-> (make-date-format date-format "UTC")
(.parse s))))

(defn format-datetime
"Format the given Date object with the :datetime-format defined in *api-options*.
NOTE: The system's default time zone is used when not provided."
([^Date date] (format-datetime date nil))
([^Date date ^String time-zone]
(let [{:keys [datetime-format]} *api-context*]
(-> (make-date-format datetime-format time-zone)
(.format date)))))

(defn parse-datetime
"Parse the given string to a Date object with the :datetime-format defined in *api-options*.
NOTE: The system's default time zone is used when not provided."
([^String s] (parse-datetime s nil))
([^String s ^String time-zone]
(let [{:keys [datetime-format]} *api-context*]
(-> (make-date-format datetime-format time-zone)
(.parse s)))))

(defn param->str
"Format the given parameter value to string."
[param]
(cond
(instance? Date param) (format-datetime param)
(sequential? param) (str/join "," param)
:else (str param)))

(defn auth->opts
"Process the given auth to an option map that might conatin request options and parameters."
[{:keys [type in param-name]} value]
(case type
:basic {:req-opts {:basic-auth value}}
:oauth2 {:req-opts {:oauth-token value}}
:api-key (case in
:header {:header-params {param-name value}}
:query {:query-params {param-name value}}
(throw (IllegalArgumentException. (str "Invalid `in` for api-key auth: " in))))
(throw (IllegalArgumentException. (str "Invalid auth `type`: " type)))))

(defn process-auth
"Process the given auth name into options, which is merged into the given opts."
[opts auth-name]
(if-let [value (get-in *api-context* [:auths auth-name])]
(merge-with merge
opts
(auth->opts (get auth-definitions auth-name) value))
opts))

(defnauths->opts
"Process the given auth names to an option map that might conatin request options and
parameters."
[auth-names]
(reduce process-auth {} auth-names))

(declare normalize-param)

(defn make-url
"Make full URL by adding base URL and filling path parameters."
[path path-params]
(let [path (reduce (fn [p [k v]]
(str/replace p (re-pattern (str "\\{" k "\\}")) (normalize-param v)))
path
path-params)]
(str (:base-url *api-context*) path)))

(defn normalize-array-param
"Normalize array paramater according to :collection-format specified in the parameter's meta data.
When the parameter contains File, a seq is returned so as to keep File parameters.
For :multi collection format, a seq is returned which will be handled properly by clj-http.
For other cases, a string is returned."
[xs]
(if (some (partial instance? File) xs)
(map normalize-param xs)
(case (-> (meta xs) :collection-format (or :csv))
:csv (str/join "," (map normalize-param xs))
:ssv (str/join " " (map normalize-param xs))
:tsv (str/join "\t" (map normalize-param xs))
:pipes (str/join "|" (map normalize-param xs))
:multi (map normalize-param xs))))

(defn normalize-param
"Normalize parameter value, handling three cases:
for sequential value, apply `normalize-array-param` which handles collection format;
for File value, use current value;
otherwise, apply `param->str`."
[param]
(cond
(sequential? param) (normalize-array-param param)
(instance? File param) param
:else (param->str param)))

(defn normalize-params
"Normalize parameters values: remove nils, format to string with `param->str`."
[params]
(-» params
(remove (comp nil? second))
(map (fn [[k v]] [k (normalize-param v)]))
(into {})))

(defn default-to-json-mime
"Default to JSON MIME if given */* MIME"
[mime]
(if (= mime "*/*")
"application/json"
mime))

(defn json-mime?
"Check if the given MIME is a standard JSON MIME or :json."
[mime]
(if mime
(or (= :json mime)
(re-matches #"(?i)application/json(;.*)?" (name mime)))))

(defn json-preferred-mime
"Choose a MIME from the given MIMEs with JSON preferred,
i.e. return JSON if included, otherwise return the first one."
[mimes]
(-> (filter json-mime? mimes)
first
(or (default-to-json-mime (first mimes)))))

(defn serialize
"Serialize the given data according to content-type.
Only JSON is supported for now."
[data content-type]
(if (json-mime? content-type)
(generate-string data {:date-format (:datetime-format *api-context*)})
(throw (IllegalArgumentException. (str "Content type \"" content-type "\" is not support for serialization")))))

(defn deserialize
"Deserialize the given HTTP response according to the Content-Type header."
[{:keys [body] {:keys [content-type]} :headers}]
(cond
(json-mime? content-type)
(try
(parse-string body true)
(catch JsonParseException e
;; Return the body string directly on JSON parsing error.
body))

;; For other cases, return the body string directly.
:else body))

(defn form-params->multipart
"Convert the given form parameters map into a vector as clj-http's :multipart option."
[form-params]
(-» form-params
(map (fn [[k v]] (array-map :name k :content v)))
vec))

(defn call-api
"Call an API by making HTTP request and return its response."
[path method {:keys [path-params body-param content-types accepts auth-names] :as opts}]
(let [{:keys [debug]} *api-context*
{:keys [req-opts query-params header-params form-params]} (auths->opts auth-names)
query-params (merge query-params (:query-params opts))
header-params (merge header-params (:header-params opts))
form-params (merge form-params (:form-params opts))
url (make-url path path-params)
content-type (or (json-preferred-mime content-types) (and body-param :json))
accept (or (json-preferred-mime accepts) :json)
multipart? (= "multipart/form-data" content-type)
req-opts (cond-> req-opts
true (assoc :urlurl :method method)
accept (assoc :accept accept)
(seq query-params) (assoc :query-params (normalize-params query-params))
(seq header-params) (assoc :headers
(normalize-params header-params))
(and content-type (not multipart?)) (assoc :content-type content-type)
multipart? (assoc :multipart (-> form-params normalize-params form-params->multipart))
(and (not multipart?) (seq form-params)) (assoc :form-params (normalize-params form-params))
body-param (assoc :body (serialize body-param content-type))
debug (assoc :debug true :debug-body true))
resp (client/request req-opts)]
(when debug
(println "Response:")
(println resp))
(assoc resp :data (deserialize resp))))
#!/bin/sh
# ref: https://help.github.com/articles/adding-an-existing-p..
#
# Usage example: /bin/sh ./git_push.sh wing328 swagger-petstore-perl "minor update"

git_user_id=$1
git_repo_id=$2
release_note=$3

if["$git_user_id" = ""]; then
git_user_id=""
echo " [INFO] No command line input provided. Set \$ git_user_id to $git_user_id"
fi

if [ "$git_repo_id" = "" ]; then
git_repo_id=""
echo "[INFO] No command line input provided. Set \$git_repo_id to $git_repo_id"
fi

if [ "$release_note" = "" ]; then
release_note=""
echo "[INFO] No command line input provided. Set \$release_note to $release_note"
fi

# Initialize the local directory as a Git repository
git init

# Adds the files in the local repository and stages them for commit.
git add .

# Commits the tracked changes and prepares them to be pushed to a remote repository.
git commit -m "$release_note"

# Sets the new remote
git_remote=`git remote`
if [ "$git_remote" = "" ]; then # git remote not defined

if [ "$GIT_TOKEN" = "" ]; then
echo "[INFO] \$GIT_TOKEN (environment variable) is not set. Using the git credential in your environment."
git remote add origin https://github.com/${git_user_id}/${git_repo_id}.git
else
git remote add origin https://${git_user_id}:${GIT_TOKEN}@github.com/${git_user_id}/${git_repo_id}.git
fi

fi

git pull origin master

# Pushes (Forces) the changes in the local repository up to the remote repository
echo "Git pushing to https://github.com/${git_user_id}/${git_repo_id}.git"
git push origin master 2>&1 | grep -v 'To https'
<?xml version= " 1.0 " encoding=" UTF-8"?>
< module cursive.leiningen.project.LeiningenProjectsManager.displayName="metrics-server:1.0.0" cursive.leiningen.project.LeiningenProjectsManager.isLeinModule="true" type= "JAVA_MODULE" version= "4" >
<componentname= "NewModuleRootManager" >
< output url= "file://$MODULE_DIR$/target/classes" />
< output-test url= "file://$MODULE_DIR$/target/classes" />
<exclude-output />
<contenturl= " file://$MODULE_DIR$" >
<url="file://$MODULE_DIR$/dev-resources" isTestSource= "false" />
<url="file://$MODULE_DIR$/src" isTestSource= "false" />
<url="file://$MODULE_DIR$/resources" isTestSource= "false" / >
<url="file://$MODULE_DIR$/test" isTestSource= "true" />
<excludeFolderurl="file://$MODULE_DIR$/target" />
< / content>
<orderEntry type= "inheritedJdk" />
<orderEntry type= "sourceFolder" forTests= "false" />
<orderEntry type="library" name="Leiningen: cheshire:5.5.0" level="project" />
<orderEntry type="library" name="Leiningen: clj-http:3.6.0" level="project" />
<orderEntry type="library" name="Leiningen: clj-tuple:0.2.2" level="project" />
<orderEntry type="library" name="Leiningen: clojure-complete:0.2.5" level="project" />
<orderEntry type= "library" name= " Leiningen: com.fasterxml.jackson.core/jackson-core:2.5.3" level= "project" / >
<orderEntry type="library" name="Leiningen: com.fasterxml.jackson.dataformat/jackson-dataformat-cbor:2.5.3" level="project" />
<orderEntry type="library" name="Leiningen: com.fasterxml.jackson.dataformat/jackson-dataformat-smile:2.5.3" level="project" />
<orderEntry type="library" name="Leiningen: commons-codec:1.10" level="project" />
<orderEntry type="library" name="Leiningen: commons-io:2.5" level="project" />
<orderEntry type="library" name="Leiningen: commons-logging:1.2" level="project" />
<orderEntry type="library" name="Leiningen: nrepl:0.6.0" level="project" />
<orderEntry type="library" name="Leiningen: org.apache.httpcomponents/httpasyncclient:4.1.3" level="project" />
<orderEntry type="library" name="Leiningen: org.apache.httpcomponents/httpclient:4.5.3" level="project" />
<orderEntry type="library" name="Leiningen: org.apache.httpcomponents/httpcore-nio:4.4.6" level="project" />
<orderEntry type="library" name="Leiningen: org.apache.httpcomponents/httpcore:4.4.6" level="project" />
<orderEntry type="library" name="Leiningen: org.apache.httpcomponents/httpmime:4.5.3" level="project" />
<orderEntry type="library" name="Leiningen: org.clojure/clojure:1.7.0" level="project" />
<orderEntry type="library" name="Leiningen: potemkin:0.4.3" level="project" />
<orderEntry type="library" name="Leiningen: riddley:0.1.12" level="project" />
<orderEntry type="library" name="Leiningen: slingshot:0.12.2" level="project" />
<orderEntry type="library" name="Leiningen: tigris:0.1.1" level="project" />
</component>
</module>
( defprojectmetrics-server "1.0.0"
:description "Sample server for stunentslabwork"
:license {:name "Apache 2.0"
:url "http://www.apache.org/licenses/LICENSE-2.0.html"}
:dependencies [[org.clojure/clojure "1.7.0"]
[clj-http "3.6.0"]
[cheshire "5.5.0"]])
